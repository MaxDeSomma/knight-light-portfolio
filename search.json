[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU Design",
    "section": "",
    "text": "Overview\nThe role of the MCU in this project was to carry out all of the chess logic and drive the lights based on the current state of the game. After setting up the required peripherals and allocating the required variables, the main loop of the MCU code would receive the board data via SPI and then check to see if anything changed. If a piece was picked up, the MCU would light the next moves of that piece. If a piece was put down, the MCU would stop lighting the squares it was previously lighting and then carry out the calculations to update the game state data based on the move.\n\n\nInterface with the LED Strip\nWhile we used the APA101 LED’s strip for individually addressable LED’s the only data sheet we could find was the APA102C the newer generation of the same LED. WHile this already was not good news the data sheet did not provide much information.\n\nThe image above was the only data on the protocol. From the physical hardware we knew that there were four pins. Vcc, GND, CLK, and SDI. From the image above we can see that a CLK must be sent into the LED’s where it will read the SDI data on the reading it on the rising edge and allowign it to change on the falling edge. The format of the data was given by the image below.\n\nThe LED strip takes in frames of 32 bit data. It must first begin with a start frame and then LED frames can be sent in with the first coding the first LED and every subsequent frame coding another LED. In the LED frame the first 3 bits need to be high, the next 5 bits control the brightness, and the last 24 bits determine the balance of RGB it will have. For instance if you wanted a really bright green light the LED frame would be 32’b1111111000000001111111100000000 or an LED with no light would be 32’b11100000000000000000000000000000.\nMany libraries exist specifically to control these types of LED’s but for our project we decided to bitbang the protocol. To bitbang the CLK and DATA we set both to be GPIO output pins. We first set CLK to be low while changing DATA to the first bit we then delayed for a giving amount and changed CLK to high and waiting the same amount of time until the process repeated for all 32 bits in a frame or all 2080 bits in the lighting of 64 LEDS.\nThe timing the strip required was not specific, just that the clock signal was symmetrical (50% duty cycle). When lighting the whole board, the MCU would start by sending start frame and then would then light each LED in the strip its desired color. In the design, blue was used as the color to signify a square. Green was used to highlight the squares a piece could move to when it was picked up. And red was used when a check occurred, lighting up the King’s square, or when checkmate occurred, lighting up the whole board in red.\n\n\nInterface with the FPGA\nThe MCU served as the controller for communication with the FPGA via SPI protocol. The FPGA would capture a board state, and once a complete board state was ready for transfer to the MCU the FPGA would assert a done signal. Once this signal was asserted, the MCU would start carrying out the SPI transactions to receive the updated state. The MCU received each row of the board as a char, and stored each row in an array of 8 chars. Once the entire board state was captured, the MCU would assert a load signal in order to enable the FPGA to capture another board state. The MCU would then go through the captured state to check for updates and carry out lighting the LEDS or doing calculations if necessary.\n\n\nChess Logic Variables\nThe MCU made use of an array of 64 booleans to represent the occupation status of the board and an array of structs to represent all of the pieces. The board array showed the current occupation status of the board, with a 1 meaning that square is occupied and a 0 meaning empty. The struct that was used to keep track of the pieces included the pieces type, color, current position, and a boolean for if the piece was protected or not. A protected piece is a piece where another piece of the same color is attacking the square that the protected piece is occupying. The struct for a piece also included an array of the pieces next possible moves, stored as a coordinate of the row and column for squares that the piece can move to. The MCU also had two arrays similar to the board array that were used to keep track of the squares in which white pieces were attacking, and another for the squares that black pieces were attacking. These arrays were used in order to calculate the squares which the king piece could move to.\n\n\nGame Initialization\nWhen a new game is started, the board array gets filled according to the starting position of a chess game, which is rows 1, 2, 7, and 8 being filled and the rest empty. This array could then be referenced as new board states come in to see if a change occurred and updated if necessary. The pieces array gets filled with each piece getting its starting position and no next moves, with the exceptions of the pawns and knights which get filled with their initial available moves. This array was then updated after each move to reflect the position change of the piece that moved, and to reflect the change in next available moves for pieces.\n\n\nUpdating Chess Variables\nWhen a new board state was received from the FPGA, the MCU would go through the new board state to see if anything changed and make any necessary updates. The MCU would receive 8 chars from the FPGA, so it would first have to convert this into booleans. The MCU went through one row of the board at a time, and would first convert char representing the row into an array of 8 booleans. The FPGA would send chars where a 1 bit represented an empty square and a 0 bit represented an occupied square, so the bits would have to be flipped before going through them. Once the char was correctly transformed into the array of 8 booleans, the MCU would then go through the row to see if a change occurred. If no change occurred, it would go onto the next row. If a change occurred, then the MCU would have a struct that housed the necessary information of the update. This struct contained a pointer to the piece that created the update and variable to signify if the update was a piece being picked up or put down.      \nWhen a piece was picked up, the MCU would first clear the lights array. It would then go through the picked up pieces next available moves and set those squares to one in the lights array. It would then light the lights according to the light array, with 0’s in the array being lit blue and 1’s being lit green. The MCU would hold the last update that occurred along with the current update as if two pick ups occurred in a row, then a piece was captured. This is because the piece that was doing the capturing is picked up, then the piece being captured is picked up, and then the piece doing the capturing is put down on the square of the piece that is captured. Thus, when a second pick up happened in a row, the captured piece’s position was set to (-1, -1) so that it was no longer on the board, and the piece from the first update was saved into the update so that its position could be updated when it was put down.\n   \nWhen a piece was put down, the MCU would first reset all of the lights to blue. It would then set all the lights to green to signify that calculations were occurring. The MCU would then go through all of the calculations to update the pieces array. It would check to see if a pawn promotion occurred, which occurs when a pawn reaches the opposing side of the board. For a pawn promotion, it was assumed the pawn would promote to a queen only as the individuals with the knowledge of when it is useful to under-promote to a knight were not our target audience. The MCU then would calculate the next moves for each piece, with the update of the piece being put down’s new position taken into account. Before doing this the MCU cleared both arrays representing the attacked squares so that they could be accurately updated during the piece calculations. Because the king moves are based on what squares the other pieces are attacking, the MCU would calculate the moves for both kings after calculating the moves for the other pieces. When calculating the king’s moves, the MCU could use the attacked squares array to check if the empty squares were available to move into, and would use the protected variable of the piece struck to check if opposing pieces could be captured. The MCU would then check to see if the king of the apposing color of the piece that was put down is in check. It would do this by going through all of next moves of the pieces of the color that was put down, and see if any piece has a next move to the king square. If the king was in check, then the MCU would check to see if the king was in checkmate. Because of how the king moves were calculated, this check would only have to check if the king had any available moves to make, and if it did not then it was checkmate. The arrays that represented the squares either color was attacking allowed for the king next moves calculation to take into account the attacked squares, so if no moves were available then it would be checkmate."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "The goal of this project was to create a smart chess board. Everytime a chess piece is picked up our chess board will calculate the pieces available moves and light up specific moves. It will take into account board boundries and other chess pieces so that there are no illegal moves as well as display when the specific piece is able to capture an opponents piece. Laslty the board will notify the player when their King is in check and when they are in Check Mate losing the game.\n\n\n\nWe wanted to create this as our Microps final project because we thought this could make chess more accessible to younger people or those unfamiliar to the game of chess. There are many pieces in chess with different move patterns. New players often overlook all the possible moves that they could make with each piece and when you can capture opposing pieces. Lastly on of the hardest parts of chess that takes experience is knowing when you are in check. Our board will help aid new players and allow them to get into the game of chess. We thought that we could use the skills we learned in Microps to bring this idea to life.\n\n\n\n\n\nTo sense when pieces are picked up. Digital hall effect sensors are used that sense a magnetic field. Each piece will be fitted with a magnet so that when it is lifted the hall effect sensors will sense a change in magnetic field and our system will be able to control the individually adressable LEDs to light up available moves and captures. In our design the FPGA is responsible for controlling 64 hall effect sensors powering them on and recieving board data from them. It will then use SPI to send the data over to the MCU. From there the MCU will control the individually addressable LED’s lighting up specific colors.\n\n\n\nOne part of this class was using new hardware that we had not previously used in this class. We decided to use two new pieces of hardware: a digital hall effect sensor and individually addressable LED’s.\n\n\nThe hall effect sensor we decided to use was a smt digital hall effect sensor. This sensor while simple allowed us to sense when a magnetic field was in range. We wanted to have one of these underneath each chess tile in the board. Our plan was wire them in a matrix similar to how keypad scanners are wired allowing use to power one row at a time and read the 8 hall effect sensors through the columns. However using 64 different hall effect sensors lead to some parasitic power and voltage loss across the columns that we had to deal with in interesting ways. One additional challenge was making sure that each magnet was calibrated so that it would set trigger the specific hall effect under the tile but not the neighboring hall effect sensors. This was done by using 3D printed calibration disk to elevate the magnet off the board.\n\n\n\nsmt hall effect sensor used\n\n\n\n\n\nThe other new hardware we used was this roll of Individually addressable LED’s that we found in the lab. There was no data sheet for this model of LED’s making it a fun challenge of trying to program them to display specific colors. We were able to find the data sheet of the newer version of the LED’s and go off that. In order to code the LED strip we ended up bitbanging the specific protocol by creating our own clock using a GPIO pin and changing the data on the falling edge similar to SPI. This ended up working extremely well and we ended up being able to set any LED to any RGB color we could think of."
  },
  {
    "objectID": "index.html#project-abstract",
    "href": "index.html#project-abstract",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "The goal of this project was to create a smart chess board. Everytime a chess piece is picked up our chess board will calculate the pieces available moves and light up specific moves. It will take into account board boundries and other chess pieces so that there are no illegal moves as well as display when the specific piece is able to capture an opponents piece. Laslty the board will notify the player when their King is in check and when they are in Check Mate losing the game."
  },
  {
    "objectID": "index.html#project-motivation",
    "href": "index.html#project-motivation",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "We wanted to create this as our Microps final project because we thought this could make chess more accessible to younger people or those unfamiliar to the game of chess. There are many pieces in chess with different move patterns. New players often overlook all the possible moves that they could make with each piece and when you can capture opposing pieces. Lastly on of the hardest parts of chess that takes experience is knowing when you are in check. Our board will help aid new players and allow them to get into the game of chess. We thought that we could use the skills we learned in Microps to bring this idea to life."
  },
  {
    "objectID": "index.html#system-design",
    "href": "index.html#system-design",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "To sense when pieces are picked up. Digital hall effect sensors are used that sense a magnetic field. Each piece will be fitted with a magnet so that when it is lifted the hall effect sensors will sense a change in magnetic field and our system will be able to control the individually adressable LEDs to light up available moves and captures. In our design the FPGA is responsible for controlling 64 hall effect sensors powering them on and recieving board data from them. It will then use SPI to send the data over to the MCU. From there the MCU will control the individually addressable LED’s lighting up specific colors."
  },
  {
    "objectID": "index.html#new-hardware",
    "href": "index.html#new-hardware",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "One part of this class was using new hardware that we had not previously used in this class. We decided to use two new pieces of hardware: a digital hall effect sensor and individually addressable LED’s.\n\n\nThe hall effect sensor we decided to use was a smt digital hall effect sensor. This sensor while simple allowed us to sense when a magnetic field was in range. We wanted to have one of these underneath each chess tile in the board. Our plan was wire them in a matrix similar to how keypad scanners are wired allowing use to power one row at a time and read the 8 hall effect sensors through the columns. However using 64 different hall effect sensors lead to some parasitic power and voltage loss across the columns that we had to deal with in interesting ways. One additional challenge was making sure that each magnet was calibrated so that it would set trigger the specific hall effect under the tile but not the neighboring hall effect sensors. This was done by using 3D printed calibration disk to elevate the magnet off the board.\n\n\n\nsmt hall effect sensor used\n\n\n\n\n\nThe other new hardware we used was this roll of Individually addressable LED’s that we found in the lab. There was no data sheet for this model of LED’s making it a fun challenge of trying to program them to display specific colors. We were able to find the data sheet of the newer version of the LED’s and go off that. In order to code the LED strip we ended up bitbanging the specific protocol by creating our own clock using a GPIO pin and changing the data on the falling edge similar to SPI. This ended up working extremely well and we ended up being able to set any LED to any RGB color we could think of."
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Project Results",
    "section": "",
    "text": "Overview\nOur project was successful in creating a learning tool for those new to chess. The board would light up the correct available moves when a piece was picked up. It also successfully displayed checks and checkmate when they occurred. Our design was successful in handling pieces capturing other pieces as the game progressed.\n\n\nHardware Results\n\nHall Effect Results\nThe hall effect sensors were successful in capturing the positions of the squares with pieces on them. The first part of the entire board was getting the hall effect sensors to accurately sense where a piece was placed. All the hall effect sensor’s Vcc’s were wired in parallel across the row and DATA across the column to save on pins as we did not have 64 pins to read each. In Figure 1 we can see the output of the FPGA scanning through the hall effect’s rows.\n\n\n\n\n\n\nFigure 1\n\n\n\nWe are only checking one of the rows but can see that the FPGA is properly setting one row high 1/8 of the time and cycling through the others. We can then check the output of the columns to make sure that the hall effect matrix is outputting the correct data.\n\n\n\n\n\n\nFigure 2\n\n\n\nIn Figure 2 we can see the column data of a column of tiles where one pawn has made one move. When a piece is on the hall effect sensor it will output a low signal and when there is no magnetic field it will output a high signal. So this properly captures where pieces are in the formation [XOXOOOXX] where X are pieces and O are empty squares. However the one thing is that the signal caps at a voltage of 1V. In order to fix this operational amplifiers were used giving us the trace in Figure 3.\n\n\n\n\n\n\nFigure 3\n\n\n\nThis looks much better and can be accurately read by the FPGA, proving our hall effect hardware worked as intended.\n\n\nSPI Results\nOnce we are able to accurately read in data from the hall effect sensors on the state of the board we had to send this data over to the MCU using SPI. Figure 4 uses the logic analyzer and captures the SPI of board state as it is when the game starts.\n\n\n\n\n\n\nFigure 4\n\n\n\nIn Figure 4 D0 -&gt; PA10 -&gt; Load, D2 -&gt; PA6 -&gt; Done, D3 -&gt; PB3 -&gt; SCLK, and D5 -&gt; PB4 -&gt; MISO. We can see in the trace that as soon as Done goes high spi beings and we can see SCLK oscillate for eight transactions of 8 bits totaling the 64 bit board state. MISO is low for the first two transactions then high for four and low for the last two which is exactly how a chess board would look with 16 pieces in the first 16 tiles no pieces in the middle 32 tiles and 16 pieces in the last 16 tiles. After 8 transactions Load goes high to reset the FPGA’s SPI protocol setting Done low and one SPI transaction is completed before Load goes low and the cycle continues as it should.\nYou can see some examples in the next few images.\n\n\n\nSPI trace where all the white pawns have been moved one tile forward\n\n\n\n\n\nZoomed in SPI trace where all the white pawns are in a zigzag\n\n\n\n\n\nSPI trace where all the pieces are in random tiles imitating the middle of a game\n\n\n\n\nLED Results\nOnce we know that the hall effect sensors were working and SPI was correctly sending the data over to the MCU the last step was to make sure the lights were being bitbanged correctly. Again we used the oscilloscope logic analyzer to capture when the LED was being sent data and clk.\n\n\n\n\n\n\nFigure 5\n\n\n\nIn Figure 5 D2 -&gt; PB0 -&gt; SDO and D5 -&gt; PA9 -&gt; CLK. We can clearly see the bit banged clock and data working as intended. If we zoom in more like in Figure 6 we can see that data changes correctly on the falling edge of the clock and that the clock has a duty cycle of 50%.\n\n\n\n\n\n\nFigure 6\n\n\n\n\n\n\nChess Software Results\n100% of the time, the board successfully lit up with the available moves for a piece. The board also displayed checks with 100% accuracy. Since the code for checking check was based on the last picked up and placed down piece’s direction, if one side was placed in check and one of its pieces was picked up and placed down, the light to signify check would no longer be lit. The board signified check mate accurately 100% of the time, as long as the pieces were moved one at a time, placed directly over magnet sensors, and in a legal(legal within the rules of chess) fashion. The software was able to successfully ignore erroneous signals from the board. Sometimes, the magnetic field from a piece would set of the sensor of an empty square adjacent to that piece’s square, and this was ignored in software by leveraging the fact that a signal of a piece being put down could only occur after a piece was picked up. Because the erroneous signal would signal a put down without a piece being picked up, ensuring a piece was picked up before a put down successfully evaded this error in signal.\n\n\nDesign in Action\n\n\n\n\n\n\nFigure 7: Chess Square with LED and PCB\n\n\n\nFigure 7 shows a picture of a chess board square with the designed PCB and LED on the LED strip under it.\n\n\n\n\n\n\nFigure 8: Board Circuit\n\n\n\nFigure 8 shows the circuit for the chess board.\n\n\n\n\n\n\nFigure 9: MCU and FPGA Circuit\n\n\n\nFigure 9 shows a picture of the circuit that includes the MCU and FPGA.\n\n\n\n\n\n\nFigure 10: Chess Piece\n\n\n\nFigure 10 shows a picture of a rook piece, along with the magnet under each piece.\n\nThe above video shows the design handling each pieces movement correctly and a capture.\n\nThe above video shows the design handling a check correctly.\n\nThe above video shows the design handling a checkmate correctly."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The role of the FPGA in this project was to interact with the hall effect sensors. The SMT hall effect sensors we used were a new hardware that needed to be powered with 3.3 V on Vcc and ground on GND. Once powered they had an OUT pin that would provide a high signal in the absense of a magnetic field and a low signal if a magnet was nearby.\n\nThe hall effect sensors were aranged in a matrix. This allowed us to wire all the Vcc pins in parallel across the rows and the OUT pin in parallel across the columns. This design significantly saves on wires. Instead of needing 64 wires for each data pin and 64 for each power, only 8 wires were needed for data and 8 for power. Each of the eight row pins was powered one at a time and the packet of eight column pins was recorded. The packets could then be stitched together to create the current state of the board indicating where pieces are.\nOnce the FPGA successfully scans through the rows and calculates the board state, it simulates the SPI protocol to send the board state over to the MCU. The MCU is then in charge of taking that board data and turning on specific LED’s and updating the current state. The FPGA coninually sends SPI packets to the MCU as the MCU loops through its while loop to make sure it has up to date board data."
  },
  {
    "objectID": "fpga.html#fpga-role",
    "href": "fpga.html#fpga-role",
    "title": "FPGA Design",
    "section": "",
    "text": "The role of the FPGA in this project was to interact with the hall effect sensors. The SMT hall effect sensors we used were a new hardware that needed to be powered with 3.3 V on Vcc and ground on GND. Once powered they had an OUT pin that would provide a high signal in the absense of a magnetic field and a low signal if a magnet was nearby.\n\nThe hall effect sensors were aranged in a matrix. This allowed us to wire all the Vcc pins in parallel across the rows and the OUT pin in parallel across the columns. This design significantly saves on wires. Instead of needing 64 wires for each data pin and 64 for each power, only 8 wires were needed for data and 8 for power. Each of the eight row pins was powered one at a time and the packet of eight column pins was recorded. The packets could then be stitched together to create the current state of the board indicating where pieces are.\nOnce the FPGA successfully scans through the rows and calculates the board state, it simulates the SPI protocol to send the board state over to the MCU. The MCU is then in charge of taking that board data and turning on specific LED’s and updating the current state. The FPGA coninually sends SPI packets to the MCU as the MCU loops through its while loop to make sure it has up to date board data."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Starting with the FPGA, it connects to 8 pins on the hall effect matrix scanning through the rows and powering each row on one by one. The columns of the hall effect matrix are then connected back into the FPGA so that the column data can stitched together as each row is only powered one at a time to get the full state of the board. One interesting note is that due to the amount of hall effect sensors we used together the data pins were lowered from a 3.3V signal to 1V signal. To boost this so that the FPGA could reliably read the data non-inverting operational amplifiers were used to gain the signal and either rail it out at 3.3V if it was high and 0V if it was low. The FPGA was then connected to the MCU using four wires that allowed for the transfer of data through SPI. Finally the MCU controlled the LED Strip which had two controllable pins sdo which is the data line and clk which it uses to read the sdo on."
  },
  {
    "objectID": "documentation.html#schematic",
    "href": "documentation.html#schematic",
    "title": "Documentation",
    "section": "",
    "text": "Starting with the FPGA, it connects to 8 pins on the hall effect matrix scanning through the rows and powering each row on one by one. The columns of the hall effect matrix are then connected back into the FPGA so that the column data can stitched together as each row is only powered one at a time to get the full state of the board. One interesting note is that due to the amount of hall effect sensors we used together the data pins were lowered from a 3.3V signal to 1V signal. To boost this so that the FPGA could reliably read the data non-inverting operational amplifiers were used to gain the signal and either rail it out at 3.3V if it was high and 0V if it was low. The FPGA was then connected to the MCU using four wires that allowed for the transfer of data through SPI. Finally the MCU controlled the LED Strip which had two controllable pins sdo which is the data line and clk which it uses to read the sdo on."
  },
  {
    "objectID": "documentation.html#pcb",
    "href": "documentation.html#pcb",
    "title": "Documentation",
    "section": "PCB",
    "text": "PCB\nSince this design required 64 smt hall effect sensors and dozens of wires we decided to design PCB’s to hold our hall effect sensors and allow us to easily wire them together in parallel across the rows and columns. Figure 1 shows this design.\n\n\n\n\n\n\nFigure 1\n\n\n\nWe ended up using 64 of the boards displayed in Figure 1, one under each tile. The hall effect sensor was located at U1 which had three pads for the IC. HC which stood for Hall Col wired the data pin of our hall effect in parallel across the column and allowed us to easily connect it to PCB’s below and above it. HR which stood for Hall Row wired the Vcc of the sensor in parallel across the row allowing us to easily connect multiple Vcc in parallel when seated next to each other.\nThe PCB also had additional through holes for a two pin LED to be connected across the rows and columns in the event that the individually addressable LED strip did not work. Luckily for us we were able to get it to work so the LED through holes were not used in our final design.\nThe PCB ended up working perfectly in our project and helped us connect all the hall effect sensors together in a matrix seen in Figure 2.\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\nPart Name\nPart #\nVendor\nLink\nQty\nPrice\n\n\n\n\nUltra-Low-Power Digital-Switch Hall Effect Sensor SMT\nDRV5032FADBZR\nTexas Instruments\nLink\n80\n$15.55\n\n\nCustom Chess Tile PCB\nNA\nPCBWay\nLink\n75\n$49.54\n\n\nScrap Wood\nNA\nMachine Shop\nNA\n1\n$0.00\n\n\nChess Pieces\nNA\nMakerspace 3D Printer\nNA\n1\n$0.00\n\n\n\nTotal Cost = $65.09"
  },
  {
    "objectID": "documentation.html#citation-and-documentations",
    "href": "documentation.html#citation-and-documentations",
    "title": "Documentation",
    "section": "Citation and Documentations",
    "text": "Citation and Documentations\nAPA102 LED data sheet - We used older APA101A LED’s but this was the closest data sheet available.\nFirst Look: APA102 RGB Pixel Addressable LED - Great youtube video on how to get these LED’s to turn on and change color\nDRV5032 Hall Effect Sensor - Datasheet for the Ultra-Low-Power Digital-Switch Hall Effect Sensor\nMCP 600X Op Amp - Datasheet for the MCP6004 Op Amps that we used"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Team",
    "section": "",
    "text": "Luke Summers: Luke is a senior computer science major at Harvey Mudd College. He has lived in southern California his whole life and enjoys golf and discrete forms of math. E155 Portfolio Website Linkedin\nMax De Somma: Max is a senior engineering major at Harvey Mudd College. He is one of the heads of Harvey Mudd’s machine shop and enjoys frequency domain mathematics. E155 Portfolio Website Linkedin\n\nAcknowledgements\nWe would like to thank the thingiverse.com user Renosis for designing chess pieces and posting them for public use. We would like to thank Xavier for advising us to use an operational amplifier in our circuit. We would lastly like to thank Kavi for teaching us the arts of bit banging."
  }
]