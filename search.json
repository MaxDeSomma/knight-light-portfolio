[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU Design",
    "section": "",
    "text": "Overview\nThe role of the MCU in this project was to carry out all of the chess logic and drive the lights based on the current state of the game. After setting up the required peripherals and allocating the required variables, the main loop of the MCU code would receive the board data via SPI and then check to see if anything changed. If a piece was picked up, the MCU would light the next moves of that piece. If a piece was put down, the MCU would stop lighting the squares it was previously lighting and then carry out the calculations to update the game state data based on the move.\n\n\nInterface with the LED Strip\nThe LED strip used would take a 32 bit value for each LED to control its color. In order to light one LED, the 32 bit color value sent to the strip was bit banged on a GPIO output pin while bit banging the clock to the strip. The clock pin was first set to low, then the first bit of the color value was set on the data line to the trip. After delaying, the clock signal was then set high and another delayed occurred. This process was repeated for each bit of the color value. The timing the strip required was not specific, just that the clock signal was symmetrical(each delay in the process was the same amount). When lighting the whole board, the MCU would start by sending a signal reserved to signify that new data was being written to the LEDs. The MCU would then light each LED in the strip its desired color, and after that it would write one more LED in order to get the last LED in the strip to update. In the design, blue was used as the color to signify a square. Green was used to highlight the squares a piece could move to when it was picked up. When a check occurred, the king’s square was lit up red. When checkmate occurred, the entire board was lit red.\n\n\nInterface with the FPGA\nThe MCU served as the controller for communication with the FPGA via SPI protocol. The FPGA would capture a board state, and once a complete board state was ready for transfer to the MCU the FPGA would assert a done signal. Once this signal was asserted, the MCU would start carrying out the SPI transactions to receive the updated state. The MCU received each row of the board as a char, and stored each row in an array of 8 chars. Once the entire board state was captured, the MCU would assert a load signal in order to enable the FPGA to capture another board state. The MCU would then go through the captured state to check for updates and carry out lighting the lights or doing calculations if necessary.\n\n\nChess Logic Variables\nThe MCU made use of an array of 64 booleans to represent the occupation status of the board and an array of structs to represent all of the pieces. The board array showed the current occupation status of the board, with a 1 meaning that square is occupied and a 0 meaning empty. The struct that was used to keep track of the pieces included the pieces type, color, current position, and a boolean for if the piece was protected or not. A protected piece is a piece where another piece of the same color is attacking the square that the protected piece is occupying. The struct for a piece also included an array of the pieces next possible moves, stored as a coordinate of the row and column for squares that the piece can move to. The MCU also had two arrays similar to the board array that were used to keep track of the squares in which white pieces were attacking, and another for the squares that black pieces were attacking. These arrays were used in order to calculate the squares which the king piece could move to.\n\n\nGame Initialization\nWhen a new game is started, the board array gets filled according to the starting position of a chess game, which is rows 1, 2, 7, and 8 being filled and the rest empty. This array could then be referenced as new board states come in to see if a change occurred and updated if necessary. The pieces array gets filled with each piece getting its starting position and no next moves, with the exceptions of the pawns and knights which get filled with their initial available moves. This array was then updated after each move to reflect the position change of the piece that moved, and to reflect the change in next available moves for pieces.\n\n\nUpdating Chess Variables\nWhen a new board state was received from the FPGA, the MCU would go through the new board state to see if anything changed and make any necessary updates. The MCU would receive 8 chars from the FPGA, so it would first have to convert this into booleans. The MCU went through one row of the board at a time, and would first convert char representing the row into an array of 8 booleans. The FPGA would send chars where a 1 bit represented an empty square and a 0 bit represented an occupied square, so the bits would have to be flipped at before going through them. Once the char was correctly transformed into the array of 8 booleans, the MCU would then go through the row to see if a change occurred. If no change occurred, it would go onto the next row. If a change occurred, then the MCU would have a struct that housed the necessary information of the update. This struct contained a pointer to the piece that created the update and variable to signify if the update was a piece being picked up or put down.      \nWhen a piece was picked up, the MCU would first clear the lights array. It would then go through the picked up pieces next available moves and set those squares to one in the lights array. It would then light the lights according to the light array, with 0’s in the array being lit blue and 1’s being lit green.\n   \nWhen a piece was put down, the MCU would first reset all of the lights to blue. It would then set all the lights to green to signify that calculations were occurring. The MCU would then go through all of the calculations to update the pieces array. It would check to see if a pawn promotion occurred, which occurs when a pawn reaches the opposing side of the board. For a pawn promotion, it was assumed the pawn would promote to a queen only as the individuals with the knowledge of when it is useful to under-promote to a knight were not our target audience. The MCU then would calculate the next moves for each piece, with the update of the piece being put down’s new position taken into account. Before doing this the MCU cleared both arrays representing the attacked squares so that they could be accurately updated during the piece calculations. Because the king moves are based on what squares the other pieces are attacking, the MCU would calculate the moves for both kings after calculating the moves for the other pieces. When calculating the king’s moves, the MCU could use the attacked squares array to check if the empty squares were available to move into, and would use the protected variable of the piece struck to check if opposing pieces could be captured. The MCU would then check to see if the king of the apposing color of the piece that was put down is in check. It would do this by going through all of next moves of the pieces of the color that was put down, and see if any piece has a next move to the king square. If the king was in check, then the MCU would check to see if the king was in checkmate. Because of how the king moves were calculated, this check would only have to check if the king had any available moves to make, and if it did not then it was checkmate. The arrays that represented the squares either color was attacking allowed for the king next moves calculation to take into account the attacked squares, so if no moves were available then it would be checkmate."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "The goal of this project was to create a smart chess board. Everytime a chess piece is picked up our chess board will calculate the pieces available moves and light up specific moves. It will take into account board boundries and other chess pieces so that there are no illegal moves as well as display when the specific piece is able to capture an opponents piece. (IF WE GET CHECK TO WORK PUT HERE)\n\n\n\nWe wanted to create this as our Microps final project because we thought this could make chess more accessible to younger people or those unfamiliar to the game of chess. There are many pieces in chess with different move patterns. New players often overlook all the possible moves that they could make with each piece and when you can capture opposing pieces. Lastly on of the hardest parts of chess that takes experience is knowing when you are in check. Our board will help aid new players and allow them to get into the game of chess. We thought that we could use the skills we learned in Microps to bring this idea to life.\n\n\n\n\n\nTo sense when pieces are picked up. Digital hall effect sensors are used that sense a magnetic field. Each piece will be fitted with a magnet so that when it is lifted the hall effect sensors will sense a change in magnetic field and our system will be able to control the individually adressable LEDs to light up available moves and captures. In our design the FPGA is responsible for controlling 64 hall effect sensors powering them on and recieving board data from them. It will then use SPI to send the data over to the MCU. From there the MCU will control the individually addressable LED’s lighting up specific colors. (AND MAYBE SPEAKER)."
  },
  {
    "objectID": "index.html#project-abstract",
    "href": "index.html#project-abstract",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "The goal of this project was to create a smart chess board. Everytime a chess piece is picked up our chess board will calculate the pieces available moves and light up specific moves. It will take into account board boundries and other chess pieces so that there are no illegal moves as well as display when the specific piece is able to capture an opponents piece. (IF WE GET CHECK TO WORK PUT HERE)"
  },
  {
    "objectID": "index.html#project-motivation",
    "href": "index.html#project-motivation",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "We wanted to create this as our Microps final project because we thought this could make chess more accessible to younger people or those unfamiliar to the game of chess. There are many pieces in chess with different move patterns. New players often overlook all the possible moves that they could make with each piece and when you can capture opposing pieces. Lastly on of the hardest parts of chess that takes experience is knowing when you are in check. Our board will help aid new players and allow them to get into the game of chess. We thought that we could use the skills we learned in Microps to bring this idea to life."
  },
  {
    "objectID": "index.html#system-design",
    "href": "index.html#system-design",
    "title": "WELCOME TO THE FUTURE OF CHESS",
    "section": "",
    "text": "To sense when pieces are picked up. Digital hall effect sensors are used that sense a magnetic field. Each piece will be fitted with a magnet so that when it is lifted the hall effect sensors will sense a change in magnetic field and our system will be able to control the individually adressable LEDs to light up available moves and captures. In our design the FPGA is responsible for controlling 64 hall effect sensors powering them on and recieving board data from them. It will then use SPI to send the data over to the MCU. From there the MCU will control the individually addressable LED’s lighting up specific colors. (AND MAYBE SPEAKER)."
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Project Results",
    "section": "",
    "text": "Test"
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The role of the FPGA in this project was to interact with the hall effect sensors. The SMT hall effect sensors we used were a new hardware that needed to be powered with 3.3 V on Vcc and ground on GND. Once powered they had an OUT pin that would provide a high signal in the absense of a magnetic field and a low signal if a magnet was nearby.\n\nThe hall effect sensors were aranged in a matrix. This allowed us to wire all the Vcc pins in parallel across the rows and the OUT pin in parallel across the columns. This design significantly saves on wires. Instead of needing 64 wires for each data pin, only 16 wires were used. Each of the eight row pins was powered one at a time and the packet of eight column pins was recorded. The packets could then be stitched together to create the current state of the board indicating where pieces are.\nOnce the FPGA successfully scans through the rows and calculates the board state, it simulates the SPI protocol to send the board state over to the MCU."
  },
  {
    "objectID": "fpga.html#fpga-role",
    "href": "fpga.html#fpga-role",
    "title": "FPGA Design",
    "section": "",
    "text": "The role of the FPGA in this project was to interact with the hall effect sensors. The SMT hall effect sensors we used were a new hardware that needed to be powered with 3.3 V on Vcc and ground on GND. Once powered they had an OUT pin that would provide a high signal in the absense of a magnetic field and a low signal if a magnet was nearby.\n\nThe hall effect sensors were aranged in a matrix. This allowed us to wire all the Vcc pins in parallel across the rows and the OUT pin in parallel across the columns. This design significantly saves on wires. Instead of needing 64 wires for each data pin, only 16 wires were used. Each of the eight row pins was powered one at a time and the packet of eight column pins was recorded. The packets could then be stitched together to create the current state of the board indicating where pieces are.\nOnce the FPGA successfully scans through the rows and calculates the board state, it simulates the SPI protocol to send the board state over to the MCU."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Team",
    "section": "",
    "text": "Luke Summers:\nMax De Somma:"
  }
]